<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.min.js"></script>
    <script id="vertexShader" type="x-shader/x-vertex">
        uniform float time;
        uniform vec2 resolution;
        void main()	{
            gl_Position = vec4( position, 1.0 );
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
        #ifdef GL_ES
precision highp float;
#endif

uniform float time;
uniform vec2 resolution;

vec2 getPos(float j, float seedX, float seedY, float cr) {
	if (mod(j, 2.) == .0) {
		return vec2(cos(seedX) * cr, sin(seedY) * cr);
	}
	return vec2(sin(seedX) * cr, cos(seedY) * cr);
}

void main( void ) {
	vec2 r=resolution;
	vec2 p=(gl_FragCoord.xy * 2.0 - resolution ) /min(r.x,r.y);
	vec4 c = vec4(0);
	float pi = 3.1415 / 5.;
	for(float i = 1.0; i < 10.; i++) {
		for (float j = 1.0; j < 5.; j++) {
			float timeE = 2.5 - (0.35 * j * j);
			float radiusAmplitude = 0.05;
			float minClusterRadiusE = .72 * (j);
			float clusterRadius = 0.19 + ( (sin(time) + minClusterRadiusE) * (radiusAmplitude * j));
			float circleRadius = 0.0025;
			for (float rgb = .0; rgb < 3.; rgb++) {
				vec2 offset;
				float glitch = (mod(time, 1.5) < abs(tan(time) * 0.2)) ? 1. : 0.;
				float sinGlitch = sin(time);
				float glitchAmplitude = 0.095 - ( 0.0079 * j);
				float rgbE = (glitch * glitchAmplitude) * rgb;
				float seedX = time * timeE * pi * 0.52 * i + rgbE;
				float seedY = time * timeE * pi * 0.52 * i;
				vec2 pos = getPos(j, seedX, seedY, clusterRadius);
				float sc = circleRadius / abs(length(p + vec2(pos.x, pos.y)) );
				if (rgb == 1.) {
					c += vec4(sc * 2., .0, .0, 1.0);
				} else if (rgb == 2.) {
					c += vec4(.0, sc * 2., .0, 1.0);
				} else {
					c += vec4(.0, .0, sc * 2., 1.0);
				}
			}
		}
	}
	gl_FragColor=c;
}
    </script>
    <script>
        var container;
        var camera, scene, renderer;
        var uniforms, material, mesh;
        var mouseX = 0, mouseY = 0,
            lat = 0, lon = 0, phy = 0, theta = 0;
        var windowHalfX = window.innerWidth / 2;
        var windowHalfY = window.innerHeight / 2;
        init();
        var startTime = Date.now();
        animate();
        function init() {
            container = document.getElementById('container');
            camera = new THREE.Camera();
            camera.position.z = 1;
            scene = new THREE.Scene();
            uniforms = {
                time: { type: "f", value: 1.0 },
                resolution: { type: "v2", value: new THREE.Vector2() }
            };
            material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent
            });
            mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
            scene.add(mesh);
            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
            container.appendChild(renderer.domElement);
            uniforms.resolution.value.x = window.innerWidth;
            uniforms.resolution.value.y = window.innerHeight;
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() {
            requestAnimationFrame(animate);
            render();
        }
        function render() {
            uniforms.time.value += 0.03;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>